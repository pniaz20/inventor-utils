<HTML>
<!-- Original URL: http://www-evasion.imag.fr/membres/francois.faure/doc/inventormentor/sgi_html/ch09.html -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "../../../../../../www.w3.org/tr/html4/loose.dtd.htm">
<html><head><meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type"><title>Chapter 9. Applying Actions</title><meta name="generator" content="DocBook XSL Stylesheets V1.49"><meta name="generator" content="SGI XSL DocBook Customization Stylesheets V1.0"><link rel="home" href="index.html" title="The Inventor Mentor:

Programming Object-Oriented 
3D Graphics with Open Inventor&#8482;,
Release 2"><link rel="up" href="index.html" title="The Inventor Mentor:

Programming Object-Oriented 
3D Graphics with Open Inventor&#8482;,
Release 2"><link rel="previous" href="ch08.html" title="Chapter 8. Curves and Surfaces"><link rel="next" href="ch10.html" title="Chapter 10. Handling Events and Selection"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 9. Applying Actions</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch08.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch10.html">Next</a></td></tr></table><hr></div><!--CONTENT_BEGIN--><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="id5471313"></a>Chapter 9. <a name="id14375"></a>Applying Actions</h2></div></div>
<p><span class="bold"><b>Chapter Objectives</b></span></p>
<p>After reading this chapter, you'll be able to do the following:</p>
<div class="itemizedlist"><ul type="disc"><li><p>Draw, or <i>render</i>, all or part of a scene graph</p>
</li>
<li><p>Print a scene graph</p>
</li>
<li><p>Create a texture map from a rendering of a scene graph</p>
</li>
<li><p>Compute a 3D bounding box for objects in a scene graph</p>
</li>
<li><p>Compute a cumulative transformation matrix (and its inverse) for objects in a scene graph</p>
</li>
<li><p>Write a scene graph to a file</p>
</li>
<li><p>Search for nodes, types of nodes, or nodes with specific names in a scene graph</p>
</li>
<li><p>Pick objects in a scene graph and obtain information about them</p>
</li>
<li><p>Perform your own action by writing callback functions that can be invoked during scene graph traversal</p>
</li>
<li><p>Write callback functions that use the primitives (points, lines, triangles) generated by Inventor shapes</p>
</li>
</ul></div><p>This chapter describes how actions are applied to an Inventor scene graph. Earlier chapters introduced you to the most commonly used action, GL rendering, which traverses the scene graph and draws it using the OpenGL Library. This chapter outlines a general model for performing any action and highlights important concepts related to other Inventor actions, including picking, calculating a bounding box, calculating a transformation matrix, writing to a file, and searching the scene graph for certain nodes.</p>
<div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5471447"></a>Inventor Actions</h2></div></div>
<p>The preceding chapters focused on building a scene graph using group, property, and shape nodes. Once you have created this scene graph, you can apply <a name="idch091"></a><i>actions</i> to it. <a href="ch09.html#id70520">Table 9-1</a> summarizes some of the ways you can use the scene graph and the specific Inventor action to use. </p>
<div class="table"><p><a name="id5471507"></a><b>Table 9-1. <a name="id70520"></a> Using Inventor Actions</b></p>
<table summary=" Using Inventor Actions" border="1"><colgroup><col><col></colgroup><thead><tr valign="top"><th valign="top"><p><span class="bold"><b>You Can Perform This Task</b></span></p>
</th><th valign="top"><p><span class="bold"><b>Using This Action</b></span></p>
</th></tr></thead><tbody><tr valign="top"><td valign="top"><p>Draw, or <i>render</i>, the scene graph</p>
</td><td valign="top"><p>		<span class="bold"><b><a name="idch092"></a></b></span>SoGLRenderAction</p>
</td></tr><tr valign="top"><td valign="top"><p>Compute a 3D bounding box for objects in the scene 
graph</p>
</td><td valign="top"><p>SoGetBoundingBoxAction<a name="idch093"></a></p>
</td></tr><tr valign="top"><td valign="top"><p>Compute a cumulative transformation matrix (and 
its inverse)</p>
</td><td valign="top"><p>	<span class="bold"><b><a name="idch094"></a></b></span>SoGetMatrixAction</p>
</td></tr><tr valign="top"><td valign="top"><p>Write the scene graph to a file</p>
</td><td valign="top"><p>	SoWriteAction</p>
</td></tr><tr valign="top"><td valign="top"><p>Search for paths to specific nodes, types of nodes, or 
nodes with specific names in the scene graph</p>
</td><td valign="top"><p>SoSearchAction<a name="idch095"></a></p>
</td></tr><tr valign="top"><td valign="top"><p>Allow objects in the scene graph to handle an event 
(see <a href="ch10.html#id10433">Chapter 10</a>)</p>
</td><td valign="top"><p>SoHandleEventAction<a name="idch096"></a></p>
</td></tr><tr valign="top"><td valign="top"><p>Pick objects in the scene graph along a ray</p>
</td><td valign="top"><p>	SoRayPickAction<a name="idch097"></a></p>
</td></tr><tr valign="top"><td valign="top"><p>Traverse the scene graph and accumulate traversal 
state, then perform your own action using callback 
functions</p>
</td><td valign="top"><p> 	SoCallbackAction<a name="idch098"></a></p>
</td></tr></tbody></table></div><p><a href="ch09.html#id11008">Figure 9-1</a> shows the portion of the class tree for actions.</p>
<p><div class="figure"><p><a name="id5471869"></a><b>Figure 9-1. <a name="id11008"></a><a name="idch099"></a>Action Classes</b></p>
<div class="mediaobject"><img src="figures/9.1action.gif"></div></div><br>
</p>
</div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5471894"></a>General Model</h2></div></div>
<p>Performing any action on the scene graph follows the general model described in this section.<a name="idch0910"></a></p>
<div class="orderedlist"><ol type="1"><li><p>Initialize the action by constructing an instance of the action class. You can construct the action on the stack as follows:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
	SbViewportRegion region(300, 200);
	SoGLRenderAction renderAction(region);
</pre></td></tr></table><p>You can also use the <span class="bold"><b>new</b></span> operator to allocate an instance of the action:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
renderAction = new SoGLRenderAction(region); 
</pre></td></tr></table><p>If you create the action with <a name="idch0911"></a><span class="bold"><b>new</b></span>, don't forget to delete the action when you finish using it.<a name="idch0912"></a></p>
</li>
<li><p>Set up special parameters for the action. For example, the constructor for <a name="idch0913"></a><span class="bold"><b>SoGLRenderAction</b></span> allows you to specify the viewport region as well as whether to inherit the current OpenGL settings. If you specify<br>
<br>
SoGLRenderAction renderAction(region, TRUE); <br>
<br>
you can use the current OpenGL values for line width, material, and so on. If you specify FALSE (or omit this parameter), Inventor sets up its own defaults.<a name="idch0914"></a></p>
</li>
<li><p>Apply the action to a node, a path, or a path list. For example:<br>
<br>
renderAction-&gt;apply(root);</p>
</li>
<li><p>Obtain the results of the action, if applicable. Some actions have additional methods that can be used with them. For example, the <a name="idch0915"></a><a name="idch0916"></a><span class="bold"><b>SoGetBoundingBoxAction</b></span> has one method, <span class="bold"><b>getBoundingBox()<a name="idch0917"></a></b></span>, that returns the bounding box computed by the action and another method, <a name="idch0918"></a><span class="bold"><b>getCenter()</b></span>, that returns the computed center.</p>
</li>
</ol></div></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5472126"></a>Applying an Action<a name="idch0919"></a></h2></div></div>
<p>When an action is applied to a scene graph, each node encountered in the graph implements its own action behavior. In some cases, a particular type of node does nothing for a particular action. <span class="bold"><b>SoMaterial</b></span> does nothing when an <span class="bold"><b>SoGetBoundingBoxAction</b></span> is applied, for example. In other cases, the action behavior is relatively simple. For example, for most actions, all classes derived from<span class="bold"><b> SoGroup</b></span> do little except traverse their children in a specified order.</p>
<p>When an action is applied, the Inventor database manages a <i>traversal state</i> (similar to the rendering state of OpenGL). The traversal state is an internal class used by Inventor to store transient state elements (parameters) during execution of the action. Typically, this management involves traversing the scene graph from top to bottom and from left to right. The elements in the traversal state are modified by the nodes encountered during this traversal. For certain actions, such as writing to a file (<a name="idch0920"></a><a name="idch0921"></a><a name="idch0922"></a><span class="bold"><b>SoWriteAction</b></span>) and accumulating a transformation matrix (<span class="bold"><b>SoGetMatrixAction<a name="idch0923"></a></b></span>), little or no traversal state is maintained. In these cases, the database does not need to keep track of all parameters inherited by nodes lower in the graph from the nodes above them.</p>
<p>The following sections focus on individual actions and how they are implemented by different nodes. You don't need to worry about exactly <i>how</i> the database manages the traversal state. You need only a general idea of which nodes implement a given action and how they implement it.</p>
<p>An action can be applied to a node, a path, or a path list.  When an action is applied to a node, the graph rooted by that node is traversed. When the action is applied to a path, all nodes in the path chain itself are traversed, as well as all nodes, if any, under the last node in the path. In addition, all nodes that affect the nodes in the path chain are also traversed (typically, these nodes are to the left and above the nodes in the path). Applying an action to a path list is similar to applying the action to each path, except that subgraphs common to two or more paths are traversed only once.</p>
</div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5472297"></a>Rendering <a name="idch0924"></a></h2></div></div>
<p>Chapters 3 through 8 illustrated how different nodes implement the <span class="bold"><b>SoGLRenderAction</b></span>. This action draws the objects represented by a scene graph. Here is how various nodes implement the <a name="idch0925"></a><span class="bold"><b>SoGLRenderAction</b></span>:</p>
<div class="itemizedlist"><ul type="disc"><li><p>If the node is a <a name="idch0926"></a><i>group</i> node, it visits each of its children in a specified order. If it is an <span class="bold"><b>SoSeparator</b></span> node, it saves the traversal state before traversing its children and restores it after traversing its children.</p>
</li>
<li><p>If the node is a <a name="idch0927"></a><i>property</i> node, it often replaces a value in the corresponding element of the traversal state (other property nodes, such as <a name="idch0928"></a><span class="bold"><b>SoTransform</b></span>, may have different behaviors). For example:</p>
<p><a name="idch0929"></a><span class="bold"><b>SoMaterial</b></span> replaces the values for the current material.</p>
<p><a name="idch0930"></a><span class="bold"><b>SoLightModel</b></span> replaces the values for the current lighting model.</p>
<p><a name="idch0931"></a><span class="bold"><b>SoDrawStyle</b></span> replaces the values for the current drawing style.</p>
<p><span class="bold"><b>SoCoordinate3<a name="idch0932"></a></b></span> replaces the values for the current coordinates.</p>
</li>
<li><p>If the node is derived from <span class="bold"><b>SoTransformation</b></span>, it modifies the current transformation matrix. Each new set of values is preconcatenated onto the existing transformation matrix.<a name="idch0933"></a></p>
</li>
<li><p>If the node is a <a name="idch0934"></a><i>shape</i> node, it causes its shape to be drawn, using the current elements in the traversal state. <a href="ch09.html#id40209">Figure 9-2</a> shows an indexed face set instanced in two different groups. When rendered as part of <i>group1</i>, it uses the current elements of the traversal state, causing a red wireframe face set to be drawn. Because subsequent nodes in <i>group2</i> modify the current material, drawing style, and transformation matrix, the next instance of the indexed face set, later in the graph, appears green and filled. It is also twice as big as the red face set and translated to a new location.</p>
<p><div class="figure"><p><a name="id5472554"></a><b>Figure 9-2. <a name="id40209"></a>Shared Instances of a Shape Node</b></p>
<div class="mediaobject"><img src="figures/fig13.2.gif"></div></div><br>
</p>
</li>
</ul></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5472577"></a>Setting the Transparency Quality<a name="idch0935"></a></h3></div></div>
<p>Use the <a name="idch0936"></a><span class="bold"><b>setTransparencyType()</b></span> method of the render action to specify the quality of rendering for transparent objects. Inventor uses three general types of transparency rendering. <a name="idch0937"></a><a name="idch0938"></a><i>Screen-door transparency</i> uses a fill pattern to simulate transparency. <a name="idch0939"></a><i>Additive blending</i> adds the transparent object to the colors already in the frame buffer. <a name="idch0940"></a><i>Alpha blending</i> uses a multiplicative algorithm for combining source and destination colors and alpha factor. Within these general categories, there are three types of additive blending and three types of alpha blending, depending on the degree of realism and amount of speed required for a particular rendering job.</p>
<p>See the <a name="idch0941"></a><i>OpenGL Programming Guide</i> for a discussion of alpha blending.</p>
<div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5472670"></a>Transparency Levels</h4></div></div>
<p>In Inventor, the transparency quality level can be specified as follows:<a name="idch0942"></a></p>
<div class="variablelist"><table border="0" cellspacing="3"><tr valign="top"><td><span class="term">SCREEN_DOOR</span></td><td width="10"> </td><td><p>use OpenGL stipple patterns for screen-door transparency.<a name="idch0943"></a></p>

</td></tr><tr valign="top"><td><span class="term">ADD</span></td><td width="10"> </td><td><p>use additive OpenGL alpha blending.</p>

</td></tr><tr valign="top"><td><span class="term">DELAYED_ADD</span></td><td width="10"> </td><td><p>use additive blending; render opaque objects first and transparent objects last.<a name="idch0944"></a></p>

</td></tr><tr valign="top"><td><span class="term">SORTED_OBJECT_ADD</span></td><td width="10"> </td><td><p><br>
use additive blending. Draw opaque objects first, then transparent objects. Sort the transparent objects by their distance from the camera and draw them from back to front (same as DELAYED_ADD because adding is commutative). <a name="idch0945"></a></p>

</td></tr><tr valign="top"><td><span class="term">BLEND</span></td><td width="10"> </td><td><p>use OpenGL alpha blending. (See <a name="idch0946"></a><a href="pr02.html#id69506">Figure In-19</a>.)</p>

</td></tr><tr valign="top"><td><span class="term">DELAYED_BLEND</span></td><td width="10"> </td><td><p><br>
use OpenGL alpha blending; render opaque objects first and transparent objects last. (See <a name="idch0947"></a><a href="pr02.html#id54525">Figure In-20</a>.)</p>

</td></tr><tr valign="top"><td><span class="term">SORTED_OBJECT_BLEND</span></td><td width="10"> </td><td><p><br>
use OpenGL alpha blending. Draw opaque objects first, then transparent objects. Sort the transparent objects by their distance from the camera and draw them from back to front. (See <a href="pr02.html#id11624">Figure In-21</a>.)</p>

</td></tr></table></div></div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5472930"></a>Trade-offs</h4></div></div>
<p>Transparency rendering with the ADD (or BLEND) level of transparency, however, works only if the transparent object is being blended into something<a name="idch0948"></a><i> already</i> in the frame buffer. This type of transparency rendering computes the transparency in the order in which the objects are rendered. <a name="idch0949"></a></p>
<p>To ensure that transparent objects are rendered last, use the  DELAYED_ADD (or DELAYED_BLEND) level. For example, if you draw a transparent cube first and then draw an opaque cylinder behind the cone, you won't see the transparency with the ADD level of transparency. In this case, you must use DELAYED_ADD (or DELAYED_BLEND). The delayed levels require more time than ADD or BLEND, but the realism is greater. (Compare <a href="pr02.html#id69506">Figure In-19</a> and <a href="pr02.html#id54525">Figure In-20</a>.)</p>
<p>For the highest degree of realism in rendering transparent objects, specify SORTED_OBJECT_ADD (or SORTED_OBJECT_BLEND). This level requires the most time but produces the best results. It renders the transparent objects after the opaque objects and also sorts the objects by distance from the camera, drawing them from back to front. (See <a name="idch0950"></a><a href="pr02.html#id11624">Figure In-21</a>.)</p>
<div class="tip"><hr noshade="noshade"><table border="0"><tr><td align="center" valign="top" width="25"><img src="figures/tip.png"></td><td align="left" valign="top"><b>Tip: </b>	Objects such as face sets do not sort within themselves, so the faces in a face set may not be drawn in the correct order for transparency.  If the object is solid, using the <a name="idch0951"></a><span class="bold"><b>SoShapeHints</b></span> node with the proper hints may improve the picture.
</td></tr></table><hr noshade="noshade"></div><p><i>Note to OpenGL programmers:<a name="idch0952"></a></i> If you are using delayed or sorted transparency levels, Inventor does not update the <a name="idch0953"></a><i>z</i> buffer for transparent objects so that they can be drawn in any order.</p>
<p>If you are using an <a name="idch0954"></a><a name="idch0955"></a><span class="bold"><b>SoXtRenderArea</b></span>, you can use the <a name="idch0956"></a><span class="bold"><b>setTransparency-<br>
Type()</b></span> method to set the quality level for rendering transparent objects.</p>
</div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5473136"></a>Antialiasing</h3></div></div>
<p>The <span class="bold"><b>SoGLRenderAction</b></span> class also provides methods for <a name="idch0957"></a><i>antialiasing</i>, techniques used to eliminate or reduce jagged lines and make objects drawn on the screen appear smooth. You can choose from two antialiasing methods:  </p>
<div class="itemizedlist"><ul type="disc"><li><p><i>Smoothing<a name="idch0958"></a></i>, which is relatively &#8220;cheap&#8221; in terms of processing time. Smoothing applies to lines and points only.</p>
</li>
<li><p><i>Using the accumulation buffer<a name="idch0959"></a></i>, which requires more processing time than smoothing but applies to the whole image and results in superior antialiasing. This technique requires an OpenGL window that supports an accumulation buffer.</p>
</li>
</ul></div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5473200"></a>Method 1:  Smoothing<a name="idch0960"></a></h4></div></div>
<p>Use the <span class="bold"><b>SoGLRenderAction::setSmoothing()</b></span> method to turn on smoothing. The <a name="idch0961"></a><a name="idch0962"></a><span class="bold"><b>isSmoothing()</b></span> method returns the current state of the Smoothing flag. This form of antialiasing is for lines and points only. Because it requires alpha or additive blending, Inventor changes the transparency type if necessary when you turn on smoothing.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5473268"></a>Method 2:  Using the Accumulation Buffer</h4></div></div>
<p>Normally, Inventor performs one rendering pass each time a render action is applied. You can use the <span class="bold"><b>SoGLRenderAction::setNumPasses()<a name="idch0963"></a><a name="idch0964"></a></b></span> method to increase the number of rendering passes for accumulation buffer antialiasing. Inventor then renders the scene multiple times, moving the camera a little bit each time, and averages the results. The more times Inventor renders a scene, the better the antialiasing. The trade-off is that increasing the number of passes also increases the amount of time required to render the scene. The number of passes can be from 1 to 255, inclusive. Specifying 1 disables multipass antialiasing.<a name="idch0965"></a></p>
<p>In addition, if you specify TRUE for the <span class="bold"><b>SoGLRenderAction::setPass-<br>
Update()<a name="idch0966"></a></b></span> method, the current contents of the accumulation buffer are copied into the currently active drawing buffer after each rendering pass. This technique slows things down but allows you to watch what happens between the incremental rendering passes. The default for <span class="bold"><b>setPassUpdate()</b></span> is FALSE.</p>
<div class="tip"><hr noshade="noshade"><table border="0"><tr><td align="center" valign="top" width="25"><img src="figures/tip.png"></td><td align="left" valign="top"><b>Tip: </b>	Use the <a name="idch0967"></a><span class="bold"><b>SoXtRenderArea::setAntialiasing()</b></span> method to turn on smoothing and to specify the number of passes for accumulation buffer antialiasing. You can specify either smoothing or accumulation buffer antialiasing, or both.
</td></tr></table><hr noshade="noshade"></div><br></div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5473380"></a>Printing and Off-screen Rendering<a name="idch0968"></a></h3></div></div>
<p>To print all or part of an Inventor scene graph, use the<a name="idch0969"></a><span class="bold"><b> SoOffscreen-Renderer</b></span> class, which in turn uses an <span class="bold"><b>SoGLRenderAction</b></span> to render an image into an off-screen memory buffer. This rendering buffer can be used both to generate an image to send to a PostScript printer (see <a name="idch0970"></a><a href="ch09.html#id35368">Example 9-1</a>) and to generate an image to be used as a texture map (see <a name="idch0971"></a><a href="ch09.html#id11467">Example 9-2</a>).</p>
<p>The image rendered into the buffer can be one of four component types:<a name="idch0972"></a></p>
<div class="variablelist"><table border="0" cellspacing="3"><tr valign="top"><td><span class="term">LUMINANCE </span></td><td width="10"> </td><td><p>one component (grayscale)</p>

</td></tr><tr valign="top"><td><span class="term">LUMINANCE_TRANSPARENCY</span></td><td width="10"> </td><td><p><br>
two components (grayscale with alpha value)</p>

</td></tr><tr valign="top"><td><span class="term">RGB</span></td><td width="10"> </td><td><p>three components (full color)</p>

</td></tr><tr valign="top"><td><span class="term">RGB_TRANSPARENCY</span></td><td width="10"> </td><td><p><br>
four components (full color with alpha value)</p>

</td></tr></table></div><p>Use the <a name="idch0973"></a><span class="bold"><b>SoOffscreenRenderer::setComponents()</b></span> method to specify the  components in the image generated before you render the image. To print black and white, use LUMINANCE.  To print color, use RGB. To generate images with transparency information, use LUMINANCE_TRANSPARENCY or RGB_TRANSPARENCY.<a name="idch0974"></a><a name="idch0975"></a></p>
<div class="tip"><hr noshade="noshade"><table border="0"><tr><td align="center" valign="top" width="25"><img src="figures/tip.png"></td><td align="left" valign="top"><b>Tip: </b>	If you want the output to go directly to a printer, use the <a name="idch0976"></a><span class="bold"><b>SoXtPrintDialog</b></span>, an Xt component. See the <i>Open Inventor C++ Reference Manual</i> for more information.
</td></tr></table><hr noshade="noshade"></div><br><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5473606"></a>How to Generate a File for Printing</h4></div></div>
<p>To write a scene graph to a file in Encapsulated PostScript (EPS) format, you first render the scene with the off-screen renderer. Then you use the <a name="idch0977"></a><span class="bold"><b>writeToPostScript()<a name="idch0978"></a></b></span> method to generate the PostScript output and write it to the given file.</p>
<p>For example, suppose you want to print a screen area that is 300 pixels by 400 pixels. Use the <a name="idch0979"></a><span class="bold"><b>setWindowSize()</b></span> method on <span class="bold"><b>SbViewportRegion</b></span> to specify the size of the viewport to be printed:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
SbViewportRegion vp;
vp.setWindowSize(SbVec2s(300, 400));

rootNode = getMyScene();

SoOffscreenRenderer renderer(vp);
renderer-&gt;render(rootNode);
renderer-&gt;writeToPostScript(stdout);
</pre></td></tr></table><p>This code fragment assumes the default pixels per inch (approximately 72). To change the number of pixels per inch, use the <a name="idch0980"></a><span class="bold"><b>setPixelsPerInch()</b></span> method on <span class="bold"><b>SbViewportRegion</b></span>. Typically, you use the resolution of the printer. For a 300 dots-per-inch (DPI) printer, you would specify the following:<a name="idch0981"></a><a name="idch0982"></a></p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
vp.setPixelsPerInch(300);
</pre></td></tr></table><p>This resolution affects line width, the size of 2D text, and point size, which are all specified in pixels.</p>
<p>You may want the printed image to be the same size as the image rendered on the screen. To determine the size of the image on the screen, first use the <span class="bold"><b>getViewportSizePixels()<a name="idch0983"></a></b></span> method on <span class="bold"><b>SbViewportRegion</b></span> to obtain the number of pixels (in <i>x</i> and <i>y</i>) of the viewport region. Then use the <span class="bold"><b>getScreenPixelsPerInch()<a name="idch0984"></a></b></span> method on<span class="bold"><b> SoOffscreenRenderer</b></span> to find out the screen resolution in pixels. </p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
screenVp = renderArea-&gt;getViewportRegion();
SbVec2s screenSize = screenVp.getViewportSizePixels();
float screenPixelsPerInch =  
         SoOffscreenRenderer::getScreenPixelsPerInch();
</pre></td></tr></table><p>Now you can calculate the size of the screen image in pixels by dividing <i>x</i> and <i>y</i> by<i> screenPixelsPerInch</i>. If you have a  300-by-400-pixel viewport on a screen with a resolution of 100 pixels per inch, your image is 3 by 4 inches. </p>
<p>To print this image at the same size, you specify the following:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
vp.<span class="bold"><b>setWindowSize</b></span>(SbVec2s(<i>x_in_inches</i> * <i>printer_DPI</i>,
<i>	y_in_inches</i> * <i>printer_DPI</i>));

vp.<span class="bold"><b>setPixelsPerInch</b></span>(<i>printer_DPI</i>);
</pre></td></tr></table><p>Your OpenGL implementation may restrict the maximum viewport size.  Use <a name="idch0985"></a><a name="idch0986"></a><span class="bold"><b>getMaximumResolution()</b></span> to obtain the maximum resolution possible for a viewport in your window system.</p>
<p><a href="ch09.html#id35368">Example 9-1</a> shows a simple function that renders a given scene graph and then saves it in a file that can be sent to a printer.<a name="idch0987"></a></p>
<div class="example"><p><a name="id5474005"></a><b>Example 9-1. <a name="id35368"></a>Printing</b></p>
</div><br><table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
SbBool 
printToPostScript (SoNode *root, FILE *file,
   SoXtExaminerViewer *viewer, int printerDPI)
{
   // Calculate size of the image in inches which is equal to
   // the size of the viewport in pixels divided by the number
   // of pixels per inch of the screen device.  This size in
   // inches will be the size of the Postscript image that will
   // be generated.
   const SbViewportRegion &amp;vp  = viewer-&gt;getViewportRegion();
   const SbVec2s &amp;imagePixSize = vp.getViewportSizePixels();
   SbVec2f imageInches;
   float pixPerInch;

   pixPerInch = SoOffscreenRenderer::getScreenPixelsPerInch();
   imageInches.setValue((float)imagePixSize[0] / pixPerInch,
                        (float)imagePixSize[1] / pixPerInch);

   // The resolution to render the scene for the printer
   // is equal to the size of the image in inches times
   // the printer DPI;
   SbVec2s postScriptRes;
   postScriptRes.setValue((short)(imageInches[0])*printerDPI,
                          (short)(imageInches[1])*printerDPI);

   // Create a viewport to render the scene into.
   SbViewportRegion myViewport;
   myViewport.setWindowSize(postScriptRes);
   myViewport.setPixelsPerInch((float)printerDPI);

   // Render the scene
   SoOffscreenRenderer *myRenderer = 
            new SoOffscreenRenderer(myViewport);
   if (!myRenderer-&gt;render(root)) {
      delete myRenderer;
      return FALSE;
   }

   // Generate PostScript and write it to the given file
   myRenderer-&gt;writeToPostScript(file);

   delete myRenderer;
   return TRUE;
}
</pre></td></tr></table><br></div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5474119"></a>Generating a Texture Map<a name="idch0988"></a></h4></div></div>
<p>You can also use the off-screen renderer to render an image to be used as a texture map. In this case, use the <span class="bold"><b>SoOffscreenRenderer::render()</b></span> method to render the image. Then use the <a name="idch0989"></a><span class="bold"><b>getBuffer()</b></span> method to obtain the buffer.</p>
<p><a href="ch09.html#id11467">Example 9-2</a> shows the typical sequence for using the rendering buffer to generate a texture map.</p>
<div class="example"><p><a name="id5474215"></a><b>Example 9-2. <a name="id11467"></a><a name="idch0990"></a> Generating a Texture Map</b></p>
</div><br><table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
#include &lt;Inventor/SoDB.h&gt;
#include &lt;Inventor/SoInput.h&gt;
#include &lt;Inventor/Xt/SoXt.h&gt;
#include &lt;Inventor/Xt/viewers/SoXtExaminerViewer.h&gt;
#include &lt;Inventor/SbViewportRegion.h&gt;
#include &lt;Inventor/misc/SoOffscreenRenderer.h&gt;
#include &lt;Inventor/nodes/SoCube.h&gt;
#include &lt;Inventor/nodes/SoDirectionalLight.h&gt;
#include &lt;Inventor/nodes/SoPerspectiveCamera.h&gt;
#include &lt;Inventor/nodes/SoRotationXYZ.h&gt;
#include &lt;Inventor/nodes/SoSeparator.h&gt;
#include &lt;Inventor/nodes/SoTexture2.h&gt;

SbBool 
generateTextureMap (SoNode *root, SoTexture2 *texture, 
   short textureWidth, short textureHeight)
{
   SbViewportRegion myViewport(textureWidth, textureHeight);

   // Render the scene
   SoOffscreenRenderer *myRenderer = 
            new SoOffscreenRenderer(myViewport);
   myRenderer-&gt;setBackgroundColor(SbColor(0.3, 0.3, 0.3));
   if (!myRenderer-&gt;render(root)) {
      delete myRenderer;
      return FALSE;
   }
   // Generate the texture
   texture-&gt;image.setValue(SbVec2s(textureWidth, textureHeight),
            SoOffscreenRenderer::RGB, myRenderer-&gt;getBuffer());

   delete myRenderer;
   return TRUE; 
}

main(int, char **argv)
{
   // Initialize Inventor and Xt
   Widget appWindow = SoXt::init(argv[0]);
   if (appWindow == NULL)
      exit(1);

   // Make a scene from reading in a file
   SoSeparator *texRoot = new SoSeparator;
   SoInput in;
   SoNode *result;

   texRoot-&gt;ref();
      in.openFile(&quot;jumpyMan.iv&quot;);
   SoDB::read(&amp;in, result);

   SoPerspectiveCamera *myCamera = new SoPerspectiveCamera;
   SoRotationXYZ *rot = new SoRotationXYZ;
   rot-&gt;axis  = SoRotationXYZ::X;
   rot-&gt;angle = M_PI_2;
   myCamera-&gt;position.setValue(SbVec3f(-0.2, -0.2, 2.0));
   myCamera-&gt;scaleHeight(0.4); 
   texRoot-&gt;addChild(myCamera);
   texRoot-&gt;addChild(new SoDirectionalLight);
   texRoot-&gt;addChild(rot);
   texRoot-&gt;addChild(result);

   // Generate the texture map
   SoTexture2 *texture = new SoTexture2; 
   texture-&gt;ref();
   if (generateTextureMap(texRoot, texture, 64, 64))
      printf (&quot;Successfully generated texture map\n&quot;);
   else
      printf (&quot;Could not generate texture map\n&quot;);
   texRoot-&gt;unref();

   // Make a scene with a cube and apply the texture to it
   SoSeparator *root = new SoSeparator;
   root-&gt;ref();
   root-&gt;addChild(texture);
   root-&gt;addChild(new SoCube);

   // Initialize an Examiner Viewer
   SoXtExaminerViewer *viewer =
            new SoXtExaminerViewer(appWindow);
   viewer-&gt;setSceneGraph(root);
   viewer-&gt;setTitle(&quot;Offscreen Rendered Texture&quot;);
   viewer-&gt;show();

   SoXt::show(appWindow);
   SoXt::mainLoop();
}
</pre></td></tr></table><br></div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5474326"></a>Caching</h3></div></div>
<p>Caching saves the result of an operation so that it doesn't need to be repeated. Inventor provides two kinds of caching:  <i>render caching</i> and <i>bounding-box caching<a name="idch0991"></a></i>. (See <a href="ch09.html#id20570">&#8220;Calculating a Bounding Box&#8221;</a> for a description of the <span class="bold"><b>SoGetBoundingBoxAction</b></span>.) For both the render action and the bounding-box action, you can specify that the results of the traversal be saved in a <i>cache</i>. The render cache, for example, contains an OpenGL display list that results from traversing the scene graph to be rendered. If the scene graph does not change, Inventor can use the contents of this cache for subsequent renderings, without traversing the scene graph at all. <a name="idch0992"></a></p>
<p>An<span class="bold"><b> SoSeparator<a name="idch0993"></a></b></span> node has two fields that are used for caching.  Possible values for these fields are AUTO, ON, or OFF. AUTO is the default value.</p>
<div class="variablelist"><table border="0" cellspacing="3"><tr valign="top"><td><span class="term"><a name="idch0994"></a><span class="bold"><b>renderCaching </b></span>(SoSFEnum</span></td><td width="10"> </td><td><p>)	<br>
specifies whether render caching is used. AUTO turns on caching when the scene graph below the separator is not changing. ON specifies to always try to build a cache, regardless of whether it is efficient.  OFF specifies not to build or use a cache.</p>

</td></tr><tr valign="top"><td><span class="term"><span class="bold"><b>boundingBoxCaching (SoSFEnum)</b></span>
</span></td><td width="10"> </td><td><p><span class="bold"><b>


<br>
</b></span>specifies whether bounding-box caching is used.</p>

</td></tr></table></div><p>The <span class="bold"><b>SoSeparator</b></span> class has a <a name="idch0995"></a><span class="bold"><b>setNumRenderCaches()</b></span> method that allows you to specify how many render caches each separator node will have. The greater the number of render caches that are built, the more memory used. You might use two caches, for example, if a viewer switches between wireframe and filled draw-styles, and the draw-style is set outside the cache. This method affects only the separator nodes that are created after it is called. Setting the number of render caches to 0 before any separators are created turns off render caching. The default number of render caches is 2.<a name="idch0996"></a><a name="idch0997"></a></p>
<div class="tip"><hr noshade="noshade"><table border="0"><tr><td align="center" valign="top" width="25"><img src="figures/tip.png"></td><td align="left" valign="top"><b>Tip: </b>If render caching is AUTO, it will take several renderings for caching to take effect.  The caching mechanism requires several renderings for comparison to determine that nothing is changing and the scene can be cached.<a name="idch0998"></a>
</td></tr></table><hr noshade="noshade"></div><br><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5474581"></a>How Caching Works</h4></div></div>
<p>The caching process begins with the separator group, as follows:</p>
<div class="orderedlist"><ol type="1"><li><p>The separator group checks whether a valid cache exists.<a name="idch0999"></a></p>
</li>
<li><p>If a valid cache exists, the separator group ignores the scene graph below it and uses the contents of the cache.</p>
</li>
<li><p>If a valid cache does not exist, the separator group checks the appropriate field to see if it should create a cache.</p>
</li>
<li><p>If caching is ON, it opens a cache, traverses the nodes under the separator group, records the results in the cache, and then calls the cache. If caching is AUTO, Inventor uses a special set of conditions to determine whether it is efficient to create a cache.</p>
</li>
</ol></div><p>The nodes under the separator group may inherit values from nodes that appear before the separator group in the graph. For example, materials, coordinates, texture coordinates, complexity nodes, normals, and bindings tend to be used by each shape.  If these values change, the cache needs to change. (Note that if a texture outside the cache changes, the cache is still valid because the shape does not send the texture calls to OpenGL. The texture is sent directly to OpenGL when the <a name="idch09100"></a><span class="bold"><b>SoTexture2</b></span> node is traversed.)</p>
<p>Be aware that these changes also invalidate the cache:<a name="idch09101"></a></p>
<div class="itemizedlist"><ul type="disc"><li><p>For <span class="bold"><b>SoText2</b></span>, changing the font or camera (because the text is screen-aligned)</p>
</li>
<li><p>For <span class="bold"><b>SoText3</b></span>, changing the profile coordinates or type of profile</p>
</li>
</ul></div><p>Inventor is conservative in determining whether the current cache is valid  (that is, caches may be invalidated and rebuilt even if inherited values have not changed). </p>
<p><a href="ch09.html#id10038">Figure 9-3</a> shows a scene graph with a transform node whose values are changing frequently and a cube. In this case, turn on caching at the separator above the cube so that the changing transform values do not invalidate the cache.<a name="idch09102"></a></p>
<p><div class="figure"><p><a name="id5474731"></a><b>Figure 9-3. <a name="id10038"></a>Caching a Shape</b></p>
<div class="mediaobject"><img src="figures/9-3.gif"></div></div><br>
</p>
<p><a href="ch09.html#id10640">Figure 9-4</a> shows a scene graph with a complexity node whose values are changing frequently and a cube. Here, you would include both the property node and the shape in the same cache, since the shape always uses the property node when it is rendered.</p>
<p><div class="figure"><p><a name="id5474817"></a><b>Figure 9-4. <a name="id10640"></a>Caching a Shape along with a Changing Property Node</b></p>
<div class="mediaobject"><img src="figures/9-4.gif"></div></div><br>
</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5474840"></a>Trade-offs</h4></div></div>
<p>Render caches can consume a great deal of memory, but they are very useful for speeding up rendering. Using the AUTO (default) value for render caching allows Inventor to determine whether creating a render cache will save time.<a name="idch09103"></a></p>
<p>Bounding-box caching is relatively inexpensive. Inventor uses bounding-<br>
box caching to speed up picking.  If bounding-box caching is on and the user picks part of the graph that contains a separator group, the separator group can first check to see if the bounding box is picked.  If not, it knows nothing under it is picked and does not need to traverse the subgraph.</p>
</div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5474872"></a>Culling Part of the Scene</h3></div></div>
<p>If you are dealing with a large scene and you know that the camera will frequently view only part of that scene, you may want to turn on render culling so that Inventor doesn't take time rendering parts of the scene that lie completely outside the camera's view. An <a name="idch09104"></a><a name="idch09105"></a><span class="bold"><b>SoSeparator</b></span> node has two flags used for culling:  <span class="bold"><b>renderCulling</b></span> and <span class="bold"><b>pickCulling</b></span>. By default, render culling is AUTO. By default, pick culling is ON. <a name="idch09106"></a></p>
<p>This description deals with render culling. (Pick culling works in a similar manner and is relatively inexpensive; you will probably simply leave it ON.) Here's a brief summary of how render culling works:<a name="idch09107"></a></p>
<div class="orderedlist"><ol type="1"><li><p>The camera puts the world-space view volume into the traversal state when it is traversed.</p>
</li>
<li><p>During traversal, the separator node tests its <span class="bold"><b>renderCulling</b></span> field. If it is ON, it culls the render area, as follows:</p>
<div class="itemizedlist"><ul type="disc"><li><p>It computes the bounding box for the separator, in object space. (This information may be cached already.)<a name="idch09108"></a></p>
</li>
<li><p>It transforms the bounding-box information into world space and compares it to the view volume in the state.</p>
</li>
<li><p>If the bounding box is completely outside the current view volume, the separator does not traverse its children.</p>
</li>
</ul></div></li>
</ol></div><p>Since Step 2 (computing the bounding box and testing it) is fairly expensive in terms of time, render culling is off by default. You'll need to evaluate your scene graph to determine whether render culling will be efficient. For example, you could have a large scene graph with external walls, and detailed electrical and plumbing connections beneath them. Although the scene graph is complex, culling won't help because all elements would be in the camera's view at the same time. However, for scenes where objects are widely separated in space, such as a scene graph for a solar system, culling can be very useful.<a name="idch09109"></a></p>
<div class="tip"><hr noshade="noshade"><table border="0"><tr><td align="center" valign="top" width="25"><img src="figures/tip.png"></td><td align="left" valign="top"><b>Tip: </b>	To facilitate culling, organize the database spatially so that objects that are close to each other in 3D space are under the same separator and objects far away from each other are under different separators. In the case of the scene graph with external walls, you could group the plumbing and electrical connections for <i>each</i> wall under a separator.
</td></tr></table><hr noshade="noshade"></div><p>Guidelines for turning on render culling are as follows:<a name="idch09110"></a></p>
<div class="itemizedlist"><ul type="disc"><li><p>In general, don't put a culling separator underneath a caching separator (that is, an <span class="bold"><b>SoSeparator</b></span> with its <span class="bold"><b>renderCaching</b></span> field set explicitly to ON). Use a culling separator under <span class="bold"><b>SoSeparator</b></span> nodes with render caching set to OFF or AUTO.</p>
<p>The reason for this guideline is that culling depends on the camera. If a separator makes a culling decision, any cache that it is part of will depend on the camera. Caches dependent on the camera will often be broken, because in most applications, the camera changes frequently. <a name="idch09111"></a></p>
<p>It's also efficient to turn on culling and caching at the <i>same</i> separator node (or turn on culling and leave caching at AUTO).</p>
</li>
<li><p>Turn on culling only for objects that are separated in space.</p>
</li>
<li><p>Turn on culling only for objects with a fairly large number of polygons, or deciding whether to cull might take longer than just drawing the object.</p>
</li>
</ul></div></div></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5475166"></a><a name="id20570"></a>Calculating a Bounding Box</h2></div></div>
<p>The 


bounding-box action computes a 3D bounding box that encloses the shapes in a subgraph under a node or defined by a path. This action also computes the center point of these shapes (see <a href="ch09.html#id30664">Example 9-3</a>).<span class="bold"><b> 


SoGet-BoundingBoxAction </b></span>is typically called on a path, which enables you to obtain a bounding box for a specific object in world coordinates. This action returns an <a name="idch09112"></a><a name="idch09113"></a><span class="bold"><b>SbBox3f</b></span>, which specifies a 3D box aligned with the <i>x</i>-, <i>y</i>-, and <i>z</i>-axes in world coordinate space. </p>
<div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5475246"></a>Create an Instance of the Action</h3></div></div>
<p>An example of creating an instance of <span class="bold"><b>SoGetBoundingBoxAction</b></span> is</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
SbViewportRegion vpReg;
vpReg.setWindowSize(300, 200);
SoGetBoundingBoxAction bboxAction (vpReg);
</pre></td></tr></table><p>This constructor has one parameter, the viewport region. This information is needed for computing the bounding box of screen-aligned or screen-sized objects, such as <a name="idch09114"></a><span class="bold"><b>SoText2</b></span>.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5475291"></a>Apply the Action</h3></div></div>
<p><span class="bold"><b>SoGetBoundingBoxAction</b></span> can be applied to the root node of a subgraph, to a path, or to a path list.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5475346"></a><a name="id50349"></a>Obtain Results</h3></div></div>
<p>Three methods access the results of <span class="bold"><b>SoGetBoundingBoxAction</b></span>:</p>
<div class="variablelist"><table border="0" cellspacing="3"><tr valign="top"><td><span class="term"><a name="idch09115"></a><span class="bold"><b>getBoundingBox()</b></span></span></td><td width="10"> </td><td><p><br>
returns an <span class="bold"><b>SbBox3f</b></span> bounding box that encloses <br>
the shape or shapes</p>

</td></tr><tr valign="top"><td><span class="term"><span class="bold"><b>getCenter()<a name="idch09116"></a></b></span></span></td><td width="10"> </td><td><p>returns the computed center point for the shapes</p>

</td></tr><tr valign="top"><td><span class="term"><span class="bold"><b>getXfBoundingBox()<a name="idch09117"></a></b></span>
</span></td><td width="10"> </td><td><p>


<br>
returns an <span class="bold"><b>SbXfBox3f</b></span> bounding box </p>

</td></tr></table></div><p>The center point returned by<span class="bold"><b> getCenter() </b></span>is defined differently for different objects. For example, the center of an <a name="idch09118"></a><span class="bold"><b>SoFaceSet</b></span> is defined as the average of its vertices' coordinates. The center of a group is defined as the average of the centers of the objects in the group.</p>
<p>An <a name="idch09119"></a><span class="bold"><b>SbXfBox3f</b></span> stores the original bounding box for a shape and the matrix that transforms it to the correct world space. The advantage to using an <span class="bold"><b>SbXfBox3f</b></span> instead of an <span class="bold"><b>SbBox3f</b></span> is that the bounding box isn't enlarged unnecessarily.  You may want to use this class if you need to perform additional transformations on the bounding box.</p>
<p><a href="ch09.html#id30664">Example 9-3</a> shows using an <span class="bold"><b>SoGetBoundingBoxAction</b></span> (<tt>bboxAction</tt>) to return the center of the graph rooted by a node so that rotations can be made around it.<a name="idch09120"></a></p>
<div class="example"><p><a name="id5475613"></a><b>Example 9-3. <a name="id30664"></a> Setting the Center Field of a Transform Node</b></p>
</div><br><table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
SbViewportRegion myViewport;
SoTransform *myTransform;

SoGetBoundingBoxAction bboxAction(myViewport);
bboxAction.apply(root);
myTransform-&gt;center = bboxAction.getCenter(); 
</pre></td></tr></table><br></div></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5475641"></a>Accumulating a Transformation Matrix<a name="idch09121"></a></h2></div></div>
<p>The <a name="idch09122"></a><span class="bold"><b>SoGetMatrixAction</b></span> returns the current transformation matrix for any node derived from <span class="bold"><b>SoTransformation</b></span> or for a path. When you apply this action to any <span class="bold"><b>SoTransformation</b></span> node, it returns the transformation matrix for that node. When you apply it to a path, <span class="bold"><b>SoGetMatrixAction</b></span> accumulates a transformation matrix for all the transformations in the subgraph defined by that path. This action enables you to convert from one coordinate space to another, typically from local space to world space (when you apply it to a path whose head node is the root of the scene graph).<a name="idch09123"></a><a name="idch09124"></a></p>
<p>An important distinction between <span class="bold"><b>SoGetMatrixAction</b></span> and other actions is that <span class="bold"><b>SoGetMatrixAction</b></span> does not traverse downward in the scene graph from the node or path to which it is applied. When applied to a node, it returns the current transformation matrix for that node only (and therefore makes sense only for transformation nodes, since all others return identity). When applied to a path, it collects transformation information for all nodes in the path but stops when it reaches the last node in the path chain.</p>
<div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5475758"></a>Create an Instance of the Action</h3></div></div>
<p>The constructor for <span class="bold"><b>SoGetMatrixAction</b></span> has no parameters: </p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
SoGetMatrixAction mtxAction;
</pre></td></tr></table><br></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5475783"></a>Apply the Action</h3></div></div>
<p><span class="bold"><b>SoGetMatrixAction</b></span> can be applied to a node or to a path.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5475797"></a>Obtain Results</h3></div></div>
<p>Two methods return the results of <a name="idch09125"></a><span class="bold"><b>SoGetMatrixAction</b></span>:</p>
<div class="variablelist"><table border="0" cellspacing="3"><tr valign="top"><td><span class="term"><a name="idch09126"></a><span class="bold"><b>getMatrix()</b></span></span></td><td width="10"> </td><td><p>returns an <a name="idch09127"></a><span class="bold"><b>SbMatrix</b></span> that is the cumulative transformation matrix for the node or path</p>

</td></tr><tr valign="top"><td><span class="term"><span class="bold"><b>getInverse()<a name="idch09128"></a></b></span></span></td><td width="10"> </td><td><p>returns a<span class="bold"><b>n SbMatrix</b></span> that is the inverse of the cumulative transformation matrix for the node or path</p>

</td></tr></table></div><p>The <span class="bold"><b>getInverse()</b></span> method enables you to take a point in world space and map it into an object's local coordinate space. See the<i> Open Inventor C++ Reference Manual</i> for a description of the many convenient methods available for <span class="bold"><b>SbMatrix</b></span>. For example, you can use <span class="bold"><b>multVecMatrix()</b></span> to transform a point by a matrix. Use <span class="bold"><b>multDirMatrix()</b></span> to transform a direction vector by a matrix. (Inventor assumes row vectors.)</p>
<div class="tip"><hr noshade="noshade"><table border="0"><tr><td align="center" valign="top" width="25"><img src="figures/tip.png"></td><td align="left" valign="top"><b>Tip: </b>	You can convert a point in one object's coordinate space into another object's space by applying a get-matrix action to the first object, transforming the point into world space using the matrix, applying a get-matrix action to the other object, and then transforming the world-space point by the inverse matrix of the second object.
</td></tr></table><hr noshade="noshade"></div><p>As an example, assume that <span class="bold"><b>SoGetMatrixAction</b></span> is applied to the path shown in <a href="ch09.html#id36048">Figure 9-5</a>. The <i>xform1</i> node contains a translation of (0.0, 0.0, 1.0), and the <i>xform2</i> node contains a scale of (0.5, 0.5, 0.5).</p>
<p><div class="figure"><p><a name="id5475982"></a><b>Figure 9-5. <a name="id36048"></a>Applying SoGetMatrixAction to a Path</b></p>
<div class="mediaobject"><img src="figures/fig13.5.gif"></div></div><br>
</p>
<p>Each new transformation is premultiplied onto the current transformation matrix. In this case, the matrix multiplication looks like this:<a name="idch09129"></a></p>
<p><div class="mediaobject"><img src="figures/ch09-8.gif"></div>
</p>
<p>In this example, <span class="bold"><b>getMatrix()</b></span> returns the following matrix:</p>
<p><div class="mediaobject"><img src="figures/ch09-10.gif"></div>
</p>
<p>For texture coordinates, use the <a name="idch09130"></a><span class="bold"><b>getTextureMatrix()</b></span> and <span class="bold"><b>getTextureInverse()</b></span> methods. See <a href="ch07.html#id39277">Chapter 7</a> and the <i>Open Inventor C++ Reference Manual</i> for more information.</p>
</div></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5476131"></a>Writing to a File<a name="idch09131"></a></h2></div></div>
<p>Inventor scene graphs can be written to a file in either ASCII or binary format.  <span class="bold"><b>SoWriteAction</b></span> is used for writing scene graphs to files. An instance of this class contains an instance of <a name="idch09132"></a><span class="bold"><b>SoOutput</b></span>, which by default writes to <span class="bold"><b>stdout</b></span>  in ASCII format. The <a name="idch09133"></a><span class="bold"><b>getOutput()</b></span> method returns a pointer to the <span class="bold"><b>SoOutput</b></span>. Other methods for <span class="bold"><b>SoOutput</b></span> include the following:</p>
<div class="variablelist"><table border="0" cellspacing="3"><tr valign="top"><td><span class="term"><span class="bold"><b>openFile()<a name="idch09134"></a></b></span></span></td><td width="10"> </td><td><p>opens and writes to a file rather than to <span class="bold"><b>stdout</b></span>.</p>

</td></tr><tr valign="top"><td><span class="term"><span class="bold"><b>setFilePointer()<a name="idch09135"></a></b></span></span></td><td width="10"> </td><td><p>explicitly sets the pointer to the file to write to.</p>

</td></tr><tr valign="top"><td><span class="term"><a name="idch09136"></a><span class="bold"><b>closeFile()</b></span></span></td><td width="10"> </td><td><p>closes the file opened with <span class="bold"><b>openFile()</b></span>. The file is closed automatically when the action is destroyed.</p>

</td></tr><tr valign="top"><td><span class="term"><a name="idch09137"></a><span class="bold"><b>setBinary()</b></span></span></td><td width="10"> </td><td><p>writes the file in binary format if TRUE; writes the file in ASCII if FALSE (the default).</p>

</td></tr><tr valign="top"><td><span class="term"><a name="idch09138"></a><span class="bold"><b>setBuffer()</b></span></span></td><td width="10"> </td><td><p>writes to a buffer in memory rather than to a file.</p>

</td></tr></table></div><p>For example, to write in binary to an already open file pointed to by <i>fp</i>:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
SoWriteAction myAction;
FILE *fp;

myAction.getOutput()-&gt;setBinary(TRUE);
myAction.getOutput()-&gt;setFilePointer(fp);
myAction.apply(root);
</pre></td></tr></table><p>To write in ASCII to a named file:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
SoWriteAction myAction;
   
myAction.getOutput()-&gt;openFile(&quot;myFile.iv&quot;);
myAction.getOutput()-&gt;setBinary(FALSE);
myAction.apply(root);
myAction.getOutput()-&gt;closeFile();
</pre></td></tr></table><p>See <a href="ch11.html#id13752">Chapter 11</a> for a complete description of the Inventor file format. Here is an example of the output of <a name="idch09139"></a><span class="bold"><b>SoWriteAction</b></span> for a subgraph:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
#Inventor V2.0 ascii
Separator {
	   Separator {
       		Transform {
 			         scaleFactor 1 2 1
       		}
       		Material {
          			ambientColor .2 .2 .2
          			diffuseColor .6 .6 .6
          			specularColor .5 .5 .5
 			         shininess .5
       		}
       		Cube{ 
       }
    	}
}
</pre></td></tr></table><br></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5476516"></a>Searching for a Node<a name="idch09140"></a></h2></div></div>
<p><span class="bold"><b>SoSearchAction<a name="idch09141"></a></b></span> searches through the scene graph for paths to specific nodes, types of nodes, or nodes with a given name. First, you initialize the action. Then, you specify the <i>node</i>, <i>node type</i>, or <a name="idch09142"></a><i>name</i> to search for (or a combination of these elements). If you specify a <i>node type<a name="idch09143"></a></i>, you can also specify whether to search for an exact type match, or to search for subclasses of the specified type as well.</p>
<div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5476570"></a>Specify the Search Criteria</h3></div></div>
<p>First, specify what you are searching for, whether you want to find all matches, and how to traverse the scene graph. </p>
<div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5476580"></a>Searching for a Node<a name="idch09144"></a></h4></div></div>
<p>If you want to search for a particular node (by pointer), use the <a name="idch09145"></a><span class="bold"><b>setNode()</b></span> method. For example, you might use <span class="bold"><b>setNode()</b></span> to search for a particular light-source node so that you can attach an editor to it. </p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5476643"></a>Searching for a Node Type<a name="idch09146"></a></h4></div></div>
<p>Rather than searching for a specific node, you may want to search for a <i>type</i> of node (see <a href="ch03.html#id18184">Chapter 3</a>). When searching for a node type, you then have the choice of searching for all nodes of a particular type, or for derivations of the given type (the default). The syntax for <span class="bold"><b>setType()</b></span> is as follows:</p>
<p><a name="idch09147"></a><span class="bold"><b>setType</b></span><tt>(SoType </tt><i>t</i><tt>, int derivedIsOk = TRUE);</tt></p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5476725"></a>Searching for a Name<a name="idch09148"></a></h4></div></div>
<p>Use the <span class="bold"><b>setName()</b></span> method to specify the name of the node to search for. (See <a href="ch03.html#id18184">Chapter 3</a> for more information on naming.)</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5476755"></a>Specify Whether to Find All Matches</h4></div></div>
<p>Use the <span class="bold"><b>setInterest()<a name="idch09149"></a></b></span> method to specify which paths to return:</p>
<div class="variablelist"><table border="0" cellspacing="3"><tr valign="top"><td><span class="term">FIRST</span></td><td width="10"> </td><td><p>returns only the first path found (the default)</p>

</td></tr><tr valign="top"><td><span class="term">LAST</span></td><td width="10"> </td><td><p>returns only the last path found</p>

</td></tr><tr valign="top"><td><span class="term">ALL</span></td><td width="10"> </td><td><p>returns all paths found</p>

</td></tr></table></div></div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5476836"></a>Specify the Type of Traversal</h4></div></div>
<p>Use the <a name="idch09150"></a><span class="bold"><b>setSearchingAll()</b></span> method to specify whether to search using normal traversal (following traversal order for switches and separators) or to search every node in the scene graph, regardless of switch settings.  The default is FALSE (search using normal traversal order).</p>
</div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5476862"></a>Apply the Action</h3></div></div>
<p><span class="bold"><b>SoSearchAction</b></span> is applied in the same manner as any other action.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5476877"></a>Obtain the Results</h3></div></div>
<p>To obtain the results of the search, use one of the following methods:</p>
<div class="variablelist"><table border="0" cellspacing="3"><tr valign="top"><td><span class="term"><a name="idch09151"></a><span class="bold"><b>getPath()</b></span> </span></td><td width="10"> </td><td><p>returns the found path (if interest is FIRST or LAST)</p>

</td></tr><tr valign="top"><td><span class="term"><span class="bold"><b>getPaths()</b></span></span></td><td width="10"> </td><td><p>returns the found path list (if interest is ALL)</p>

</td></tr></table></div><p>See the <i>Open Inventor C++ Reference Manual</i> for a complete description of all methods available for <span class="bold"><b>SoSearchAction</b></span>.</p>
<p>The following example searches a scene graph for any node derived from <span class="bold"><b>SoLight</b></span>. If it does not find one, it creates and adds an <span class="bold"><b>SoDirectionalLight<a name="idch09152"></a></b></span>. This example searches for only the first match by calling <a name="idch09153"></a><span class="bold"><b>setInterest</b></span>-<br>
<span class="bold"><b>(SoSearchAction::FIRST)</b></span>. </p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
SoSearchAction mySearchAction;

// Look for first existing light derived from class SoLight
mySearchAction.setType(SoLight::getClassTypeId());
mySearchAction.setInterest(SoSearchAction::FIRST);
    
mySearchAction.apply(root);
if (mySearchAction.getPath() == NULL) { // No lights found

   // Add a default directional light to the scene
   SoDirectionalLight *myLight = new SoDirectionalLight;
   root-&gt;insertChild(myLight, 0);
}
</pre></td></tr></table><br></div></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5477068"></a>Picking<a name="idch09154"></a></h2></div></div>
<p><span class="bold"><b>SoRayPickAction</b></span> finds objects along a ray from the camera through a point on the near plane of the view volume. This ray is typically specified by giving the coordinates of a window-space pixel through which it passes.  <span class="bold"><b>SoRayPickAction</b></span> traverses the scene graph you apply the action to and then returns the paths to all shapes along the picking ray, sorted from nearest to farthest. The picking action is primarily interested in geometry, transformation, and shape nodes.</p>
<div class="tip"><hr noshade="noshade"><table border="0"><tr><td align="center" valign="top" width="25"><img src="figures/tip.png"></td><td align="left" valign="top"><b>Tip: </b>	The <a name="idch09155"></a><span class="bold"><b>SoSelection</b></span> node picks objects automatically. You don't need to explicitly use the pick action to select objects. The <a name="idch09156"></a><span class="bold"><b>SoHandleEvent</b></span> action also performs picking automatically. In addition, the <span class="bold"><b>SoEventCallback<a name="idch09157"></a></b></span> node allows you to register a callback function that is invoked whenever a certain event (such as a mouse press) occurs over a specified object. See <a href="ch10.html#id10433">Chapter 10</a> for more information on <span class="bold"><b>SoSelection</b></span>, <span class="bold"><b>SoHandleEvent</b></span>, and <span class="bold"><b>SoEventCallback</b></span>. 
</td></tr></table><hr noshade="noshade"></div><br><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5477204"></a>Picking Style<a name="idch09158"></a></h3></div></div>
<p>By default, all objects in the scene graph are pickable (even invisible and transparent objects). To make an object or group of objects invisible to the pick action, insert an <a name="idch09159"></a><span class="bold"><b>SoPickStyle</b></span> node in the scene graph and set its <span class="bold"><b>style</b></span> field to UNPICKABLE. Anything that follows in the scene graph cannot be picked until the <a name="idch09160"></a><span class="bold"><b>SoPickStyle</b></span> node is reset to SHAPE (to pick points on the shape objects in the scene) or BOUNDING_BOX (to pick points on the bounding boxes for the objects in the scene). BOUNDING_BOX pick style is most often used for <a name="idch09161"></a><span class="bold"><b>SoText3</b></span> nodes. The pick style, like all other properties, is saved and restored by <span class="bold"><b>SoSeparator</b></span> groups.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5477294"></a>Create an Instance of the Action</h3></div></div>
<p>The constructor for <span class="bold"><b>SoRayPickAction</b></span> has one parameter, the viewport region (a required parameter).</p>
<p>An example of creating an instance of <span class="bold"><b>SoRayPickAction</b></span> is </p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
SbViewportRegion myViewport;
SoRayPickAction myPickAction(myViewport);
</pre></td></tr></table><p>The viewport region is used to compute the bounding boxes for screen-aligned objects such as <a name="idch09162"></a><span class="bold"><b>SoText2</b></span>.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5477349"></a>Set Parameters</h3></div></div>
<p>Before you apply the picking action, you can set the following parameters:</p>
<div class="itemizedlist"><ul type="disc"><li><p>Ray to pick along</p>
</li>
<li><p>Whether to return all objects along the ray, or only the closest one</p>
</li>
</ul></div><p>The picking ray can be specified in one of two ways:  either specify a window point and a radius, or specify a point and a direction in world space. The first method is the more typical for interactive programs, since you are generally most interested in the area underneath the cursor.<a name="idch09163"></a></p>
<div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5477388"></a>Specifying the Picking Ray with a Window Point</h4></div></div>
<p>Before you apply the picking action, use the <a name="idch09164"></a><span class="bold"><b>setPoint()</b></span> and <a name="idch09165"></a><span class="bold"><b>setRadius()</b></span> methods to set the ray to be used for picking. </p>
<p>The ray to pick along is typically specified in <a name="idch09166"></a><i>viewport coordinates</i>, where <br>
(0, 0) is the lower left corner of the viewport and (<i>vpWidth</i>-1, <i>vpHeight</i>-1) is the upper right corner (see <a href="ch09.html#id26714">Figure 9-6</a>). In the figure, the viewport is 1000 by 1000. The near plane of the camera maps to the picking viewport.</p>
<p>To make it easier to pick lines and points, the ray can be augmented to be a cone (for a perspective camera; see <a href="ch09.html#id26714">Figure 9-6</a>) or a cylinder (for an orthographic camera). Use the <span class="bold"><b>setRadius()</b></span> method to control the size of this cone or cylinder where it intersects the near plane of the camera. (The default radius is 5 pixels.) Things that are picked must fall within this cone (or cylinder), as follows: <a name="idch09167"></a></p>
<div class="itemizedlist"><ul type="disc"><li><p>For points and lines, if any part of the shape falls within this cone, it is picked. (A sphere drawn with LINES draw-style is still picked as a solid sphere.)</p>
</li>
<li><p>For all other shapes, the ray itself must intersect the shape for it to be picked.</p>
<p><div class="figure"><p><a name="id5477555"></a><b>Figure 9-6. <a name="id26714"></a>Cone Representing the Picking Ray for a Perspective Camera</b></p>
<div class="mediaobject"><img src="figures/9.6.pickingcone.gif"></div></div><br>
</p>
</li>
</ul></div></div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5477580"></a>Specifying the Picking Ray with a World-Space Ray</h4></div></div>
<p>You can also specify the picking ray by specifying a world-space ray along which to pick. The ray is defined as a starting point, a direction vector, and a near distance and far distance for the picked objects. No radius is used. For example:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
SbViewportRegion viewport(400, 300);
SbVec2s cursorPosition(250, 125);

SoRayPickAction myPickAction(viewport);

myPickAction.setRay(SbVec3f(0.0, 0.0, 0.0),  // starting point
                    SbVec3f(0.0, 0.0, -1.0); // direction vector
</pre></td></tr></table><p>This example uses the default near and far distances, which disables clipping to the near and far planes.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5477615"></a>Picking the Closest Object </h4></div></div>
<p>Use the <span class="bold"><b>setPickAll()<a name="idch09168"></a></b></span> method to specify whether you want information returned for all objects picked (sorted from closest to farthest), or just the closest one. Specify TRUE for all objects, or FALSE (the default) for only the closest one.</p>
</div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5477661"></a>Apply the Action</h3></div></div>
<p>The picking action can be applied to either a node, a path, or a path list. To apply the picking action to the root node of a scene graph:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
pickAction-&gt;apply(rootNode);
</pre></td></tr></table><br></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5477683"></a>Obtain Results<a name="idch09169"></a></h3></div></div>
<p>The results of the pick are stored in an <a name="idch09170"></a><span class="bold"><b>SoPickedPoint</b></span> (for the first hit) or an <a name="idch09171"></a><span class="bold"><b>SoPickedPointList</b></span> (for information on all hit objects). Use the methods on <span class="bold"><b>SoPickedPoint</b></span> to obtain this information.</p>
<div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5477726"></a>SoPickedPoint<a name="idch09172"></a></h4></div></div>
<p>An <span class="bold"><b>SoPickedPoint</b></span> represents a point on the surface of an object that was picked. The picked point contains the point of intersection, the surface normal and texture coordinates at that point, the index into the current set of materials, and the path to the object that was intersected. Use the following methods on <span class="bold"><b>SoPickedPoint</b></span> to obtain this information:</p>
<div class="variablelist"><table border="0" cellspacing="3"><tr valign="top"><td><span class="term"><a name="idch09173"></a><span class="bold"><b>getPoint()</b></span></span></td><td width="10"> </td><td><p>returns the intersection point, in world space.</p>

</td></tr><tr valign="top"><td><span class="term"><span class="bold"><b>getNormal()<a name="idch09174"></a></b></span>
</span></td><td width="10"> </td><td><p>returns the surface normal at the intersected point, in world space.</p>

</td></tr><tr valign="top"><td><span class="term"><span class="bold"><b>getTextureCoords()<a name="idch09175"></a></b></span>
</span></td><td width="10"> </td><td><p>


<br>
returns the texture coordinates at the intersection point, in image space.</p>

</td></tr><tr valign="top"><td><span class="term"><span class="bold"><b>getMaterialIndex()<a name="idch09176"></a></b></span>
</span></td><td width="10"> </td><td><p>


<br>
returns the index into the current set of materials that is used at the intersection point.  If the materials are interpolated between vertices, the index corresponds to the material at the closest vertex.</p>

</td></tr><tr valign="top"><td><span class="term"><span class="bold"><b>getPath()<a name="idch09177"></a></b></span></span></td><td width="10"> </td><td><p>returns the path to the object that was intersected.</p>

</td></tr></table></div><p>For example:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
SoPath *pathToPickedObject;

const SoPickedPoint *myPickedPoint = 
         myPickAction.getPickedPoint();
if (myPickedPoint != NULL)
   pathToPickedObject = myPickedPoint-&gt;getPath();
</pre></td></tr></table><p><a href="ch09.html#id84072">Figure 9-7</a> shows the path returned by an <span class="bold"><b>SoRayPickAction</b></span> (which can be obtained with the <span class="bold"><b>getPath()</b></span> method on <span class="bold"><b>SoPickedPoint</b></span>).  This path contains a pointer to each node in the path to the picked object.  Use the following methods on <span class="bold"><b>SoPickedPoint</b></span> to obtain information about the pick in the <i>object space</i> of a particular node in the path chain.  You pass in a pointer to the node you are interested in, or use the default (NULL) to obtain information about the tail of the path:</p>
<div class="variablelist"><table border="0" cellspacing="3"><tr valign="top"><td><span class="term"><span class="bold"><b>getObjectPoint()<a name="idch09178"></a></b></span>
</span></td><td width="10"> </td><td><p>


returns the intersection point, in object space</p>

</td></tr><tr valign="top"><td><span class="term"><span class="bold"><b>getObjectNormal()<a name="idch09179"></a></b></span>
</span></td><td width="10"> </td><td><p>


<br>
returns the surface normal for the picked point</p>

</td></tr><tr valign="top"><td><span class="term"><span class="bold"><b>getObjectTextureCoords()<a name="idch09180"></a></b></span>
</span></td><td width="10"> </td><td><p>


<br>
returns the texture coordinates for the picked point</p>
<p><div class="figure"><p><a name="id5478167"></a><b>Figure 9-7. <a name="id84072"></a>Path to Picked Point and Detail List</b></p>
<div class="mediaobject"><img src="figures/9-8.gif"></div></div><br>
</p>

</td></tr></table></div></div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5478192"></a>Using an SoDetail</h4></div></div>
<p>Each node in the picked path may have an associated <span class="bold"><b>SoDetail</b></span> in which it can store additional information about the pick. For some classes, this associated <span class="bold"><b>SoDetail</b></span> is NULL.  <a href="ch09.html#id15740">Table 9-2</a> shows the classes that store information in a subclass of <span class="bold"><b>SoDetail</b></span>.</p>
<p><a href="ch09.html#id30783">Figure 9-8</a> shows the class tree for <span class="bold"><b>SoDetail</b></span>.</p>
<p><div class="figure"><p><a name="id5478274"></a><b>Figure 9-8. <a name="id30783"></a><a name="idch09181"></a><a name="idch09182"></a>Detail Classes</b></p>
<div class="mediaobject"><img src="figures/9.8sodetail.gif"></div></div><br>
</p>
<p><a name="id18982"></a></p>
<div class="table"><p><a name="id5478307"></a><b>Table 9-2. <a name="id15740"></a><a name="idch09183"></a>Classes That Store an SoDetail</b></p>
<table summary="Classes That Store an SoDetail" border="1"><colgroup><col><col><col></colgroup><thead><tr valign="top"><th valign="top"><p><span class="bold"><b>Class Name</b></span></p>
</th><th valign="top"><p><span class="bold"><b>Type of Detail Added</b></span></p>
</th><th valign="top"><p><span class="bold"><b>Information Provided</b></span></p>
</th></tr></thead><tbody><tr valign="top"><td valign="top"><p>SoCone</p>
</td><td valign="top"><p>SoConeDetail</p>
</td><td valign="top"><p>Contains information about 
which part of the cone was 
hit</p>
</td></tr><tr valign="top"><td valign="top"><p>SoCube</p>
</td><td valign="top"><p>SoCubeDetail</p>
</td><td valign="top"><p>Contains information about 
which face (part) of the 
cube was hit</p>
</td></tr><tr valign="top"><td valign="top"><p>SoCylinder</p>
</td><td valign="top"><p>SoCylinderDetail</p>
</td><td valign="top"><p>Contains information about 
which part of the cylinder 
was hit</p>
</td></tr><tr valign="top"><td valign="top"><p>SoText2, SoText3</p>
</td><td valign="top"><p>SoTextDetail</p>
</td><td valign="top"><p>Specifies the index of the 
string that was hit; the 
index of the character 
within the string that was 
hit; which part of the text 
was hit; the object-space 
bounding box of the 
character that was 
intersected</p>
</td></tr><tr valign="top"><td valign="top"><p>SoFaceSet; all vertex-based 
shapes except lines, points, 
and NURBS</p>
</td><td valign="top"><p>SoFaceDetail</p>
</td><td valign="top"><p>Specifies which face in the 
shape was hit</p>
</td></tr><tr valign="top"><td valign="top"><p>SoLineSet, 
SoIndexedLineSet</p>
</td><td valign="top"><p>SoLineDetail</p>
</td><td valign="top"><p>Specifies which line in the 
line set was hit</p>
</td></tr><tr valign="top"><td valign="top"><p>SoPointSet</p>
</td><td valign="top"><p>SoPointDetail</p>
</td><td valign="top"><p>Specifies which point in the 
point set was hit</p>
</td></tr></tbody></table></div><p>Use the <a name="idch09184"></a><span class="bold"><b>getDetail()</b></span> method on<span class="bold"><b> SoPickedPoint</b></span> to return the detail for a given node in the picked path. This method takes a pointer to a node in the picked path. It returns information for the tail of the path if NULL or no node is specified. For example, to determine whether a cylinder was hit and, if so, whether it was the top part of the cylinder, the code would be as follows:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
const SoDetail *pickDetail = myPickedPoint-&gt;getDetail();
if (pickDetail != NULL &amp;&amp; pickDetail-&gt;getTypeId() ==
                        SoCylinderDetail::getClassTypeId()) {
   // Picked object is a cylinder
   SoCylinderDetail *cylDetail = 
            (SoCylinderDetail *) pickDetail;

   // See if top of the cylinder was hit
   if (cylDetail-&gt;getPart() == SoCylinder::TOP) {
      printf(&quot;Top of cylinder was hit\n&quot;);
   }
}
</pre></td></tr></table><p>The following fragment shows how you could find the closest vertex to the hit point of a face-based shape using an <a name="idch09185"></a><span class="bold"><b>SoFaceDetail</b></span>. An <span class="bold"><b>SoFaceDetail</b></span> contains an array of <a name="idch09186"></a><span class="bold"><b>SoPointDetails</b></span>. You can examine these details to find the coordinates of the point closest to the hit point by using the <span class="bold"><b>getCoordinateIndex()</b></span> method on <span class="bold"><b>SoPointDetail</b></span>. Finding the node that contains the coordinates is left to the application. (You can create a search action, apply it to the picked path, and ask for the last <span class="bold"><b>SoCoordinate3</b></span> node in the path. But you also need to know something about the structure of your graph&#8212;for example, whether it contains Override flags or Ignore flags that may affect the search.) </p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
//   This function finds the closest vertex to an intersection
//   point on a shape made of faces, passed in the
//   &quot;pickedPoint&quot; argument. It returns the SoCoordinate3 node
//   containing the vertex's coordinates in the &quot;coordNode&quot;
//   argument and the index of the vertex in that node in the
//   &quot;closestIndex&quot; argument. If the shape is not made of faces
//   or there were any other problems, this returns FALSE.

static SbBool
findClosestVertex(const SoPickedPoint *pickedPoint,
            SoCoordinate3 *&amp;coordNode, int &amp;closestIndex)
{
   const SoDetail *pickDetail = pickedPoint-&gt;getDetail();

   if (pickDetail != NULL &amp;&amp; pickDetail-&gt;getTypeId() ==
                             SoFaceDetail::getClassTypeId()) {
      // Picked object is made of faces
      SoFaceDetail *faceDetail = (SoFaceDetail *) pickDetail;

      // Find the coordinate node that is used for the faces.
      // Assume that it's the last SoCoordinate3 node traversed
      // before the picked shape.
      SoSearchAction  mySearchAction;
      mySearchAction.setType(SoCoordinate3::getClassTypeId());
      mySearchAction.setInterest(SoSearchAction::LAST);
      mySearchAction.apply(pickedPoint-&gt;getPath());

      if (mySearchAction.getPath() != NULL) {  // We found one
         coordNode = (SoCoordinate3 *)
                     mySearchAction.getPath()-&gt;getTail();

         // Get the intersection point in the object space
         // of the picked shape
         SbVec3f objIntersect = pickedPoint-&gt;getObjectPoint();

         // See which of the points of the face is the closest
         // to the intersection point
         float minDistance = 1e12;
         closestIndex = -1;
         for (int i = 0; i &lt; faceDetail-&gt;getNumPoints(); i++) {
            int pointIndex =
                  faceDetail-&gt;getPoint(i)-&gt;getCoordinateIndex();
            float curDistance = (coordNode-&gt;point[pointIndex] -
                  objIntersect).length();
            if (curDistance &lt; minDistance) {
               closestIndex = pointIndex;
               minDistance = curDistance;
            }
         }

         if (closestIndex &gt;= 0)
            return TRUE;
      }
   }

   return FALSE;
}
</pre></td></tr></table><br></div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5478831"></a>Using the Pick Action<a name="idch09187"></a></h3></div></div>
<p><a href="ch09.html#id31391">Example 9-4</a> shows setting up the pick action and writing the path to the picked object to <span class="bold"><b>stdout</b></span>.</p>
<div class="example"><p><a name="id5478858"></a><b>Example 9-4. <a name="id31391"></a>Writing the Path to the Picked Object</b></p>
</div><br><table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
SbBool
writePickedPath (SoNode *root, 
   const SbViewportRegion &amp;viewport, 
   const SbVec2s &amp;cursorPosition)
{
   SoRayPickAction myPickAction(viewport);

   // Set an 8-pixel wide region around the pixel
   myPickAction.setPoint(cursorPosition);
   myPickAction.setRadius(8.0);
   
   // Start a pick traversal
   myPickAction.apply(root);
   const SoPickedPoint *myPickedPoint = 
            myPickAction.getPickedPoint();
   if (myPickedPoint == NULL)
      return FALSE;         // no object was picked

   // Write out the path to the picked object
   SoWriteAction myWriteAction;
   myWriteAction.apply(myPickedPoint-&gt;getPath());

   return TRUE;
}
</pre></td></tr></table><br></div></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5478905"></a>Calling Back to the Application<a name="idch09188"></a></h2></div></div>
<p>The <a name="idch09189"></a><span class="bold"><b>SoCallbackAction</b></span> allows you to traverse the scene graph and accumulate state. It includes methods for calling back to application functions whenever nodes of a specified type are encountered during the traversal. At every node, the callback function has access to the entire Inventor traversal state. It can thus query any element in the state, such as the current coordinates, current normals, or current material binding. See the <a name="idch09190"></a><a name="idch09191"></a><i>Open Inventor C++ Reference Manual</i> on <span class="bold"><b>SoCallbackAction</b></span> for a description of all state query functions.</p>
<p>The callback action also allows you to register callback functions that are called whenever certain shape nodes are traversed. The primitives used to draw the shape are passed to the callback function for use by the application.</p>
<p>This action provides a convenient mechanism for adding your own action to Inventor without subclassing (see <a name="idch09192"></a><i>The Inventor Toolmaker</i> for information on creating a new action). It is particularly useful for C programmers who want to add functionality to scene graph traversal.<a name="idch09193"></a></p>
<div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5479035"></a>Create an Instance of the Action</h3></div></div>
<p>An example of creating an instance of <span class="bold"><b>SoCallbackAction</b></span> is as follows:</p>
<table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
SoCallbackAction cbAction;
</pre></td></tr></table><br></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5479060"></a>Register Callback Functions</h3></div></div>
<p>Inventor provides a number of methods for setting callback functions for a node. Each method takes a node type, a pointer to the user callback function, and a pointer to user data. The function is called whenever a node of the specified type or a subclass of that type, is encountered during traversal of the scene graph.</p>
<div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5479074"></a>General-Purpose Callback Functions<a name="idch09194"></a></h4></div></div>
<p>The following functions are set for any type of node:</p>
<div class="variablelist"><table border="0" cellspacing="3"><tr valign="top"><td><span class="term"><a name="idch09195"></a><span class="bold"><b>addPreCallback()</b></span>
</span></td><td width="10"> </td><td><p><span class="bold"><b>


<br>
</b></span>adds a callback function that is called just before a node of a particular type is traversed</p>

</td></tr><tr valign="top"><td><span class="term"><a name="idch09196"></a><span class="bold"><b>addPostCallback()</b></span>
</span></td><td width="10"> </td><td><p><span class="bold"><b>


<br>
</b></span>adds a callback function that is called just after a node of a particular type is traversed</p>

</td></tr><tr valign="top"><td><span class="term"><span class="bold"><b>addPreTailCallback()<a name="idch09197"></a></b></span>
</span></td><td width="10"> </td><td><p>


<br>
adds a callback function that is called just before the last node in the path is traversed</p>

</td></tr><tr valign="top"><td><span class="term"><span class="bold"><b>addPostTailCallback()<a name="idch09198"></a></b></span>
</span></td><td width="10"> </td><td><p>


<br>
adds a callback function that is called just after the last node in the path is traversed</p>

</td></tr></table></div><p>In the case of a separator node, the <span class="bold"><b>addPreCallback() </b></span>method is called before the children are traversed, and the <span class="bold"><b>addPostCallback()</b></span> method is called after the children are traversed but before the state is restored. The <span class="bold"><b>addPreTailCallback()</b></span> and <span class="bold"><b>addPostTailCallback()</b></span> methods are used only when you apply the callback action to a path.</p>
<p>A general-purpose callback function must return one of three values:<a name="idch09199"></a></p>
<div class="variablelist"><table border="0" cellspacing="3"><tr valign="top"><td><span class="term">SoCallbackAction::CONTINUE</span></td><td width="10"> </td><td><p><br>
continue traversal of the scene graph.</p>

</td></tr><tr valign="top"><td><span class="term">SoCallbackAction::PRUNE</span></td><td width="10"> </td><td><p><br>
do not go any lower in the scene graph; continue traversal of the rest of the scene graph above and to the right.</p>

</td></tr><tr valign="top"><td><span class="term">SoCallbackAction::ABORT</span></td><td width="10"> </td><td><p><br>
stop traversal of the scene graph and pop state back up to the root.</p>

</td></tr></table></div></div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5479350"></a>Primitive Generation<a name="idch09200"></a></h4></div></div>
<p>The following callback functions are set for a particular type of <a name="idch09201"></a><i>shape</i> node.  When these callback functions are set and the shape is traversed, primitives for the shape are generated, the callback function is invoked, and the primitives are passed to the callback function. You might use  <span class="bold"><b>addTriangleCallback()</b></span>, for example, if you are writing your own renderer and you want to tessellate all filled objects into triangles.</p>
<div class="variablelist"><table border="0" cellspacing="3"><tr valign="top"><td><span class="term"><a name="idch09202"></a><span class="bold"><b>addTriangleCallback()</b></span>
</span></td><td width="10"> </td><td><p><span class="bold"><b>


<br>
</b></span>adds a callback function to a node that generates triangles, such as <span class="bold"><b>SoFaceSet</b></span> or <span class="bold"><b>SoNurbsSurface</b></span></p>

</td></tr><tr valign="top"><td><span class="term"><span class="bold"><b>addLineSegmentCallback()<a name="idch09203"></a></b></span></span></td><td width="10"> </td><td><p><br>
adds a callback function to a node that generates line segments, such as <span class="bold"><b>SoLineSet</b></span> or <span class="bold"><b>SoIndexedLineSet</b></span> (but not to <span class="bold"><b>SoFaceSet </b></span>or related classes even when the draw-style is LINES)</p>

</td></tr><tr valign="top"><td><span class="term"><span class="bold"><b>addPointCallback()<a name="idch09204"></a></b></span>
</span></td><td width="10"> </td><td><p> <br>
adds a callback function to a node that generates points, such as <span class="bold"><b>SoPointSet </b></span>(but not to <span class="bold"><b>SoFaceSet</b></span> or <span class="bold"><b>SoLineSet</b></span> even when the draw-style is POINTS)</p>

</td></tr></table></div><p>For triangles, the associated callback is of the following form:</p>
<p>void <span class="bold"><b>SoTriangleCB</b></span>(void *<i>userData</i>, SoCallbackAction *<i>action</i>, <br>
  	const SoPrimitiveVertex *<i>v1</i>,<br>
	const SoPrimitiveVertex *<i>v2</i>,<br>
	const SoPrimitiveVertex *<i>v3</i>);</p>
<p>Here, the callback function is called once for each triangle the shape generates. An example of using this callback function would be if you are writing a ray tracer and want to deal with only one type of data structure for all polygonal shapes.  A triangle callback function can be registered on spheres, cones, cylinders, and NURBS surfaces, as well as on face sets and quad meshes.<a name="idch09205"></a></p>
<p>An <a name="idch09206"></a><span class="bold"><b>SoPrimitiveVertex</b></span> is a vertex of a primitive shape (triangle, line segment, or point) that is generated by a callback action.  It contains an object-space point, normal, texture coordinate, material index, and a pointer to an instance of an <a name="idch09207"></a><span class="bold"><b>SoDetail</b></span> subclass. The detail may contain additional information about the vertex.</p>
<div class="tip"><hr noshade="noshade"><table border="0"><tr><td align="center" valign="top" width="25"><img src="figures/tip.png"></td><td align="left" valign="top"><b>Tip: </b>Your callback function can use the value of the draw-style element from the state if you want to determine if the triangles would be rendered as points or lines. For example:
</td></tr></table><hr noshade="noshade"></div><br><table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
    
    if(SoDrawStyleElement::get(action-&gt;getState())==
    SoDrawStyleElement::LINES)
</pre></td></tr></table><p>    ...//do something<br>
    <br>
See <i>The Inventor Toolmaker</i> for more information on elements.<a name="idch09208"></a></p>
</div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5479762"></a>Apply the Action</h3></div></div>
<p><span class="bold"><b>SoCallbackAction</b></span> can be applied to a node, a path, or a path list.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5479777"></a>Using a Callback for Generated Primitives<a name="idch09209"></a></h3></div></div>
<p><a href="ch09.html#id28463">Example 9-5</a>  shows using the callback action to decompose a sphere into a set of triangle primitives. </p>
<div class="example"><p><a name="id5479820"></a><b>Example 9-5. <a name="id28463"></a><span class="bold"></span>Using a Triangle Callback Function</b></p>
</div><br><table bgcolor="#E0E0E0" width="90%" border="1" cellpadding="10"><tr><td><pre class="literallayout">
...
SoSphere *mySphere = new SoSphere;
mySphere-&gt;ref();
printSpheres(mySphere);
...
void
printSpheres(SoNode *root)
{
   SoCallbackAction myAction;

   myAction.addPreCallback(SoSphere::getClassTypeId(), 
            printHeaderCallback, NULL);
   myAction.addTriangleCallback(SoSphere::getClassTypeId(), 
            printTriangleCallback, NULL);

   myAction.apply(root);
}

SoCallbackAction::Response
printHeaderCallback(void *, SoCallbackAction *, 
      const SoNode *node)
{
   printf(&quot;\n Sphere &quot;);
   // Print the node name (if it exists) and address
   if (! !node-&gt;getName())
      printf(&quot;named \&quot;%s\&quot; &quot;, node-&gt;getName());
   printf(&quot;at address %#x\n&quot;, node);

   return SoCallbackAction::CONTINUE;
}

void
printTriangleCallback(void *, SoCallbackAction *,
   const SoPrimitiveVertex *vertex1,
   const SoPrimitiveVertex *vertex2,
   const SoPrimitiveVertex *vertex3)
{
   printf(&quot;Triangle:\n&quot;);
   printVertex(vertex1);
   printVertex(vertex2);
   printVertex(vertex3);
}

void
printVertex(const SoPrimitiveVertex *vertex)
{
   const SbVec3f &amp;point = vertex-&gt;getPoint();
   printf(&quot;\tCoords     = (%g, %g, %g)\n&quot;, 
               point[0], point[1], point[2]);

   const SbVec3f &amp;normal = vertex-&gt;getNormal();
   printf(&quot;\tNormal     = (%g, %g, %g)\n&quot;, 
               normal[0], normal[1], normal[2]);
}
</pre></td></tr></table><br></div></div></div><!--CONTENT_END--><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch08.html">Prev</a> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Table of Contents</a></td><td width="40%" align="right"> <a accesskey="n" href="ch10.html">Next</a></td></tr><tr><td width="40%" align="left">Chapter 8. Curves and Surfaces </td><td width="20%" align="center"> </td><td width="40%" align="right">Chapter 10. Handling Events and Selection </td></tr></table></div></body></html>
